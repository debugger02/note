## jvm 运行时数据区域

<div align="center">
    <img src="../../zzzimg/java/jvm内存.png" width="70%"/>
</div>

**线程共享区域**

堆：Java堆（JavaHeap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是`存放对象实例与数组`，几乎所有的对象实例都在这里分配内存。`Java堆是垃圾收集器管理的主要区域`，因此很多时候也被称做“GC堆”。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、ToSurvivor空间，比例为 8 ：1 ：1 。

方法区（MethodArea）: 与Java堆一样，是各个线程共享的内存区域，它`用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据`。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。运行时常量池（Runtime ConstantPool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant PoolTable），`用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。`


**线程私有区域**

程序计数器（Program CounterRegister）: 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果正在执行的是Native方法，这个计数器值则为空（Undefined）。

Java虚拟机栈（Java Virtual MachineStacks）:也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：`每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。`

本地方法栈（Native MethodStack）: 与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。


## 垃圾回收

垃圾回收发生的区域： java 堆；

垃圾回收做哪些事情？

1. 哪些内存需要回收？
2. 什么时候回收？
3. 如何回收？

### 哪些内存需要回收？

对已经“死去”的对象进行回收，即这些对象已不在被引用，如何判断对象是否被引用有两种方式：

- 引用计数法
- 可达性分析算法


**引用计数算法**

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

缺点：主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。

**可达性分析算法**

通过一系列的称为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GCRoots没有任何引用链相连（用图论的话来说，就是从GCRoots到这个对象不可达）时，则证明此对象是不可用的。

在Java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI（即一般说的Native方法）引用的对象。

### 什么时候需要回收？

概括来说，当进行内存分配时，产生了内存空间的连续片段不够用时，需要进行回收，具体的回收发生时刻如下：

- 对象优先分配在Eden区，若Eden区没有足够的空间，虚拟机发生一次Minor GC。
  
- 大对象直接进入老年代，若老年代没有足够的连续区域，虚拟机发生一次Full GC。

- 在发生Minor GC时，虚拟机会检测每次晋升到老年代的平均大小是否大于老年代的剩余大小，如果大于则直接进行一次Full GC，如果小于，则查看HandlePromotionFailure是否允许担保失败，如果允许则进行Minor GC，如果不允许则直接进入Full GC。当复制算法中survivor区域无法容纳存活对象时，需要老年代进行担保，将存活对象直接进入老年代。

Minor GC：指发生在新生代区域的垃圾回收，因为java对象具备朝生夕灭的特性，所以Minor GC发生比较频繁，一般回收速度也比较快。

Full GC：发生在老年代的GC，经常伴随至少1次的Minor GC，Full GC的速度一般比Minor GC慢10倍以上。


### 如何进行回收？

**标记-清除算法**  

首先标记所有待回收的对象，标记完成后统一回收；

要真正宣告一个对象死亡，至少要`经历两次标记过程`：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做`F-Queue`的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃，finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。

缺点：

一是效率问题，标记和清除效率都不高；  
二是空间问题，标记清除后会产生大量的不连续内存碎片。空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。


**复制算法**

将内存划分成容量相等的两块，每次使用其中一块，当这块用完了就将存活的对象复制到另一块上，再把使用的一块一次清理掉。

- 优点：高效 
- 缺点：浪费内存

新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。

**标记-整理算法**

复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

**分代收集算法**

当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在`新生代`中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用`复制算法`，只需要付出少量存活对象的复制成本就可以完成收集。而`老年代`中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用`“标记—清理”或者“标记—整理”算法来进行回收。`


## 垃圾收集器

Java 虚拟中通常包含多个不同的垃圾收集器以满足不同场景的垃圾回收，HotSpot 虚拟机的垃圾收集器如下图所示：

<div align="center"> 
    <img src="../../zzzimg/java/垃圾收集器.png" width="50%">
</div>

上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。

### CMS 收集器

### G1 收集器
