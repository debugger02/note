## 重要的意识
无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。Java 中首要的同步机制是 `synchronized` 关键字，它提供了独占锁。除此之外，术语“同步”还包括`volatile`变量，显示锁和原子变量的使用。

## Java 内存模型

**主内存与工作内存**

java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处变量与java编程中所说的略有不同。

java 内存模型规定了所有的变量存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中额变量。

<div align="center">
    <img src="../zzzimg/java/javaMem.png" width="50%">
</div>

- 内存模型的8种操作: lock unlock read load use assign store write
- java内存操作三种特性：原子性、可见性、有序性

## java 线程

**线程的实现**

线程的实现（不仅是java）主要有三种方式：使用内核实现、使用用户线程实现、使用用户进程加轻量级进程混合实现。

`内核线程`

内核线程（Kernel Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上，支持多线程的内核叫多线程内核。

`轻量级进程`

程序一般不会直接使用内核线程，而是使用内核线程的高级接口，轻量级进程（Light Weight Process, LWP)，轻量级进程就是通常意义上所讲的线程，轻量级进程与内核线程之间1：1的关系称作一对一的线程模型，如下图：

<div align="center">
    <img src="../zzzimg/java/LWT.png" width="50%">
</div>

局限：
1. 基于内核线程实现，所以各种进程操作都需要进行系统调用，需要在用户态和内核态之间来回切换，代价较高。
2. 支持轻量级进程会消耗一定的内核资源（如内核栈空间），因此一个系统支持的轻量级进程的数量有限。

`用户线程`

广义上来说，除了内核线程之外的，都是用户线程（User Thread, UT)，包括轻量级进程。

狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程的存在。用户线程的所有操作不需要在
用户态、内核态切换，操作可以十分消耗快速。但是线程的管理没有内核的支援，都需要用户自己管理，因此比较复杂，所以现在使用比较少。

`混合实现`

内核线程与用户线程一起使用的实现方式，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间，操作依然廉价，并且支持大规模的用户线程并发。而操作系统提供支持的轻量级进程作为用户线程和内核线程之间的桥梁，通过内核来管理线程。在这种混合模式中，用户线程与轻量级进程的数量比是 M : N 的关系，如下图：

<div align="center">
    <img src="../zzzimg/java/mix.png" width="50%">
</div>

### java 线程调度

线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是`协同式线程调度`（Cooperative Threads-Scheduling）和`抢占式线程调度`（Preemptive Threads-Scheduling）。

使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。好处：实现简单，坏处：线程执行时间不可控制。

抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，`Thread.yield()`可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，Java使用的线程调度方式就是抢占式调度。

**线程状态转换**

Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别如下：

- `新建（New）：`创建后尚未启动的线程处于这种状态。

- `运行（Runable）`：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。

- `无限期等待（Waiting）`：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态：
    - 没有设置Timeout参数的Object.wait()方法。
    - 没有设置Timeout参数的Thread.join()方法。
    - LockSupport.park()方法。
  
- `限期等待（Timed Waiting）`：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
  - Thread.sleep()方法。
  - 设置了Timeout参数的Object.wait()方法。
  - 设置了Timeout参数的Thread.join()方法。
  - LockSupport.parkNanos()方法。
  - LockSupport.parkUntil()方法

- `阻塞（Blocked）`：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。

- `结束（Terminated）`：已终止线程的线程状态，线程已经结束执行。

<div align="center">
    <img src="../zzzimg/java/thread state.png" width="50%">
</div>

**线程安全**

线程安全定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

将Java语言中各种操作共享的数据分为以下5类：
- 不可变：绝对线程安全；
- 绝对线程安全
- 相对线程安全
- 线程兼容
- 线程对立

Java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它在构造函数之后是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，如果读者还没想明白这句话，不妨想一想java.lang.String类的对象，它是一个典型的不可变对象，我们调用它的substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。
