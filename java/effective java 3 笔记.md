本书的作用：知道什么情况下使用哪一种设计模式

## 考虑使用静态工厂方法替代构造函数

注意，静态工厂方法与设计模式中的工厂方法模式不同[Gamma95]。本条目中描述的静态工厂方法在设计模式中
没有直接的等价。类可以为其客户端提供静态工厂方法，而不是公共构造方法。提供静态工厂方法而不是公共构造方法有优点也有
缺点。

### 优点

1. 拥有可以识别的名称，区分不同构造方法的参数列表与功能；
2. 不需要每次调用都创造一个对象
3. 可以返回其返回类型的子类型
4. 返回对象的类可以根据输入参数的不同而不同
5. 在编写包含该方法的类时，返回的对象的类不需要存在。这种灵活的静态工厂方法构成了服务提供者框架的基础，比如 Java 数据库连接 API(JDBC)

### 限制

1. 没有公共或受保护构造方法的类不能被子类化
2. 程序员很难找到它们。 它们不像构造方法那样在 API 文档中突出


## 当构造方法参数过多时使用 builder 模式

JavaBeans 模式本身有严重的缺陷。由于构造方法在多次调用中被分割，所以在构造过程中 JavaBean 可能处于不一致的状态。该类没有通过检查构造参数参数的有效性来执行一致性的选项。在不一致的状态下尝试使用对象可能会导致与包含 bug 的代码大相径庭的错误，因此很难调试。一个相关的缺点是，JavaBeans 模式排除了让类不可变的可能性（条目 17），并且需要在程序员的部分增加工作以确保线程安全。

## 使用私有构造方法或枚举类实现 Singleton 属性

私有构造方法：暴露一个静态公共方法用来获取私有构造方法的引用。

单一元素枚举类通常是实现单例的最佳方式。注意，如果单例必须继承 Enum 以外的父类 (尽管可以声明一个 Enum 来实现接口)，那么就不能使用这种
方法。

## 使用私有构造方法执行非实例化

只有当类不包含显式构造方法时，才会生成一个默认构造方法，因此可以通过包含一个私有构造方法来实现类的非实例化

## 依赖注入优于硬连接资源

## 消除过期的对象引用

垃圾收集语言中的内存泄漏（更适当地称为无意的对象保留 unintentional object retentions）是隐蔽的。 如果无意中保留了对象引用，那么不仅这个对象排除在垃圾回收之外，而且该对象引用的任何对象也是如此。 即使只有少数对象引用被无意地保留下来，也可以阻止垃圾回收机制对许多对象的回收，这对性能产生很大的影响。这类问题的解决方法很简单：`一旦对象引用过期，将它们设置为 null`。

## 使用 try-with-resources 语句替代 try-finally 语句

结论很明确：在处理必须关闭的资源时，使用 try-with-resources 语句替代 try-finally 语句。 生成的代码更简洁，
更清晰，并且生成的异常更有用。 try-with-resources 语句在编写必须关闭资源的代码时会更容易，也不会出错，而
使用 try-finally 语句实际上是不可能的。

## 始终重写 toString 方法

## 最小化可变性

要使一个类不可变，请遵循以下五条规则：
1. 不要提供修改对象状态的方法（也称为 mutators）。
2. 确保这个类不能被继承。 这可以防止粗心的或恶意的子类，假设对象的状态已经改变，从而破坏类的不可变行为。 防止子类化通常是通过 final 修饰类，但是我们稍后将讨论另一种方法。
3. 把所有属性设置为 final。 通过系统强制执行，清楚地表达了你的意图。 另外，如果一个新创建的实例的引用从一个线程传递到另一个线程而没有同步，就必须保证正确的行为，正如内存模型[JLS，17.5; Goetz06,16] 所述。
4. 把所有的属性设置为 private。 这可以防止客户端获得对属性引用的可变对象的访问权限并直接修改这些对象。 虽然技术上允许不可变类具有包含基本类型数值的公共 final 属性或对不可变对象的引用，但不建议这样做，因为它不允许在以后的版本中更改内部表示（条目 15 和 16）。
5. 确保对任何可变组件的互斥访问。 如果你的类有任何引用可变对象的属性，请确保该类的客户端无法获得对这些对象的引用。 切勿将这样的属性初始化为客户端提供的对象引用，或从访问方法返回属性。 在构造方法，访问方法和 readObject 方法（条目 88）中进行防御性拷贝（条目 50）。

## 组合优于继承

在包中使用继承是安全的，其中子类和父类的实现都在同一个程序员的控制之下。对应专门为了继承而设计的，并且有文档说明的类来说（条目 19），使用继承也是安全的。 然而，从普通的具体类跨越包级边界继承，是危险的。


## 接口优于抽象类

Java 有两种机制来定义允许多个实现的类型：接口和抽象类。 由于在 Java 8 [JLS 9.4.3] 中引入了接口的默认方法（default methods ），因此这两种机制都允许为某些实例方法提供实现。 一个主要的区别是要实现由抽象类定义的类型，类必须是抽象类的子类。 因为 Java 只允许单一继承，所以对抽象类的这种限制严格限制了它们作为类型定义的使用。 任何定义所有必需方法并服从通用约定的类都可以实现一个接口，而不管类在类层次结构中的位置。

## 为后代设计接口

在 Java 8 之前，不可能在不破坏现有实现的情况下为接口添加方法。 如果向接口添加了一个新方法，现有的实现通常会缺少该方法，从而导致编译时错误。 在 Java 8 中，添加了默认方法（default method）构造[JLS 9.4]，目的是允许将方法添加到现有的接口。 但是增加新的方法到现有的接口是充满风险的。

在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时会失败。 虽然不是非常普遍，但这个问题也不是一个孤立的事件。 在 Java 8 中添加到集合接口的一些方法已知是易受影响的，并且已知一些现有的实现会受到影响。

应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的，在这种情况下，你应该仔细考虑，以确定现有的接口实现是否会被默认的方法实现所破坏。然而，默认方法对于在创建接口时提供标准的方法实现非常有用，以减轻实现接口的任务（条目 20）。

准则是清楚的。 尽管默认方法现在是 Java 平台的一部分，但是非常悉心地设计接口仍然是非常重要的。 虽然默认方法可以将方法添加到现有的接口，但这样做有很大的风险。 如果一个接口包含一个小缺陷，可能会永远惹怒用户。 如果一个接口严重缺陷，可能会破坏包含它的 API。


## 接口仅用来定义类型

当类实现接口时，该接口作为一种类型（type），可以用来引用类的实例。因此，一个类实现了一个接口，因此
表明客户端可以如何处理类的实例。为其他目的定义接口是不合适的。


## 类层次结构优于标签类

像 Java 这样的面向对象的语言为定义一个能够表示多种风格对象的单一数据类型提供了更好的选择：子类型化（subtyping）。即使用抽象类，抽象类主要用于对大量类的公共方法进行抽象，而不同的方法则由子类自己实现。接口对方法的实现功能相当有限。、

## 支持使用静态成员类而不是非静态类

有四种嵌套类：静态成员类，非静态成员类，匿名类和局部类。 除了第一种以外，剩下的三种都被称为内部类（inner class）。 这个条目告诉你什么时候使用哪种类型的嵌套类以及为什么使用。

`静态成员类`是最简单的嵌套类。 最好把它看作是一个普通的类，恰好在另一个类中声明，并且可以访问所有宿主类的成员，甚至是那些被声明为私有类的成员。 静态成员类是其宿主类的静态成员，并遵循与其他静态成员相同的可访问性规则。 如果它被声明为 private ，则只能在宿主类中访问，等等。静态成员类的一个常见用途是作为公共帮助类，仅在与其外部类一起使用时才有用。

`非静态成员类`的一个常见用法是定义一个 Adapter [Gamma95]，它允许将外部类的实例视为某个不相关类的实例。

如果你声明了一个不需要访问宿主实例的成员类，总是把 static 修饰符放在它的声明中，使它成为一个静态成员类，而不是非静态的成员类。 如果你忽略了这个修饰符，每个实例都会有一个隐藏的外部引用给它的宿主实例。 如前所述，存储这个引用需要占用时间和空间。 更严重的是，并且会导致即使宿主类在满足垃圾回收的条件时却仍然驻留在内存中（条目 7）。 由此产生的内存泄漏可能是灾难性的。 由于引用是不可见的，所以通常难以检测到。

`私有静态成员类`的常见用法是表示由它们的宿主类表示的对象的组件。

`匿名类`的适用性有很多限制。 除了在声明的时候之外，不能实例化它们。 你不能执行 instanceof 方法测试
或者做任何其他需要你命名的类。 不能声明一个匿名类来实现多个接口，或者继承一个类并同时实现一个接口。 匿
名类的客户端不能调用除父类型继承的成员以外的任何成员。 因为匿名类在表达式中出现，所以它们必须保持简短
—— 约十行或更少 —— 否则可读性将受到影响。

`局部类`是四种嵌套类中使用最少的。 一个局部类可以在任何可以声明局部变量的地方声明，并遵守相同的作用域规则。 局部类与其他类型的嵌套类具有共同的属性。 像成员类一样，他们有名字，可以重复使用。 就像匿名类一样，只有在非静态上下文中定义它们时，它们才会包含实例，并且它们不能包含静态成员。 像匿名类一样，应该保持简短，以免损害可读性。

## 不要使用原始类型

使用原始类型（没有类型参数的泛型）是合法的，但是你不应该这样做。 如果你使用原始类型，则会丧失泛型的所有安全性和表达上的优势。

## 消除非检查警告

尽可能地消除每一个未经检查的警告。如果你不能消除警告，但你可以证明引发警告的代码是类型安全的，那么（并且只能这样）用
`@SuppressWarnings(“unchecked”)` 注解来抑制警告。每当使用 @SuppressWarnings(“unchecked”) 注解时，请添加注释，说明为什么是安全的。尽可能小的范围内使用 @SuppressWarnings(“unchecked”) 注解来禁止警告。

## 列表优于数组

无论哪种方式，你不能把一个 String 类型放到一个 Long 类型容器中，但是用一个数组，你会发现在运行时产生了一个错误；对于列表，可以在编译时就能发现错误。 当然，你宁愿在编译时找出错误。

## 优先考虑泛型

## 使用限定通配符来增加 API 的灵活性

为了获得最大的灵活性，对代表生产者或消费者的输入参数使用通配符类型。 如果一个输入参数既是一个生产者又是一个消费者，那么
通配符类型对你没有好处：你需要一个精确的类型匹配，这就是没有任何通配符的情况。这里有一个助记符来帮助你记住使用哪种通配符类型： `PECS 代表： producer-extends，consumer-super`。换句话说，如果一个参数化类型代表一个 T 生产者，使用 <? extends T> ；如果它代表 T 消费者，则使
用 <? super T> 。

如果类型参数在方法声明中只出现一次，请将其替换为通配符。 如果它是一个无限制的类型参数，请将其替换为无限制的通配符; 如果它是一个限定类型参数，则用限定通配符替换它。

## 合理地结合泛型和可变参数

当你调用一个可变参数方法时，会创建一个数组来保存可变参数；那个应该是实现细节的数组是可见的。 因此，当可变参数具有泛型或参数化类型时，会导致编译器警告混淆。

## 使用枚举类型替代整型常量

要将数据与枚举常量相关联，请声明实例属性并编写一个构造方法，构造方法带有数据并将数据保存在属性中

## 注解优于命名模式

## 始终使用 Override 注解

Java 类库包含几个注解类型。对于典型的程序员来说，最重要的是 @Override 。此注解只能在方法声明上使用，它表明带此注解的方法声明重写了父类的声明。如果始终使用这个注解，它将避免产生大量的恶意 bug。

## 使用标记接口定义类型

标记接口（marker interface），不包含方法声明，只是指定（或“标记”）一个类实现了具有某些属性的接口。 例如，考虑 Serializable 接口（第 12 章）。通过实现这个接口，一个类表明它的实例可以写入 ObjectOutputStream （或“序列化”）

`标记接口与标记注解`相比具有两个优点。
1. 首先，标记接口定义了一个由标记类实例实现的类型；标记注解则不会。 标记接口类型的存在允许在编译时捕获错误，如果使用标记注解，则直到运行时才能捕获错误
2. 标记接口对于标记注解的另一个优点是可以更精确地定位目标

## lambda 表达式优于匿名类

与方法和类不同，lambda 没有名称和文档; 如果计算不是自解释的，或者超过几行，则不要将其放入 lambda 表达式中。 一行代码对于 lambda 说是理想的，三行代码是合理的最大值。

## 明智审慎地使用 Stream

## 优先使用 Collection 而不是 Stream 来作为方法的返回类型

## 检查参数有效性

## 返回空的数组或集合，不要返回 null

永远不要返回 null 来代替空数组或集合

## 明智审慎地返回 Optional

这允许该方法返回一个空结果，以表明不能返回有效的结果。返回 Optional 的方法比抛出异常的方法更灵活、更容易使用，而且比返回 null 的方法更不容易出错。

Optional.empty() 返回一个空的 Optional， Optional.of(value) 返回一个包含给定非 null 值的 Optional。 将 null 传递给 Optional.of(value) 是一个编程错误。 如果这样做，该方法通过抛出 NullPointerException 异常作为回应。 Optional.ofNullable(value) 方法接受一个可能为 null 的值，如果传入 null 则返回一个空的 Optional。永远不要通过返回 Optional 的方法返回一个空值：它破坏 Optional 设计的初衷。

## 最小化局部变量的作用域

## for-each 循环优于传统 for 循环

## 若需要精确答案就应避免使用 float 和 double 类型

float 和 double 类型特别不适合进行货币计算，因为不可能将 0.1（或 10 的任意负次幂）精确地表示为 float 或 double。

## 基本数据类型优于包装类

## 当使用其他类型更合适时应避免使用字符串

## 当心字符串连接引起的性能问题

要获得能接受的性能，请使用 StringBuilder 代替 String 来存储正在构建的语句

## 通过接口引用对象

```java
// Good - uses interface as type
Set<Son> sonSet = new LinkedHashSet<>();
// Bad - uses class as type!
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```

## 接口优于反射

反射允许一个类使用另一个类，即使在编译前者时后者并不存在。然而，这种能力是有代价的：
- 失去了编译时类型检查的所有好处， 包括异常检查。如果一个程序试图反射性地调用一个不存在的或不可访问的方法，它将在运行时失败，除非你采取了特殊的预防措施。
- 执行反射访问所需的代码既笨拙又冗长。 写起来很乏味，读起来也很困难。
- 性能降低。 反射方法调用比普通方法调用慢得多。到底慢了多少还很难说，因为有很多因素在起作用。在我的机器上，调用一个没有输入参数和返回 int 类型的方法时，用反射执行要慢 11 倍。


## 明智审慎地本地方法

## 对可恢复的情况使用受检异常，对编程错误使用运行时异常

Java 程序设计语言提供了三种 throwable：受检异常（checked exceptions）、运行时异常（runtime exceptions）和错误（errors）。

在决定使用受检异常还是非受检异常时，主要的原则是： 如果期望调用者能够合理的恢复程序运行，对于这种
情况就应该使用受检异常。

有两种非受检的 throwable：运行时异常和错误。在行为上两者是等同的：它们都是不需要也不应该被捕获的 throwable。如果程序抛出非受检异常或者错误，往往属于不可恢复的情形，程序继续执行下去有害无益。如果程序没有捕捉到这样的 throwable，将会导致当前线程中断（halt），并且出现适当的错误消息。

## 优先使用标准的异常

## 每个方法抛出的异常都需要创建文档

## 保持失败原子性

一般而言，失败的方法调用应该使对象保持在被调用之前的状态。不要出现再赋值等情况。

## 同步访问共享的可变数据

为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。千万不要使用 Thread.stop 方法

## 并发工具优于 wait 和 notify

## 文档应包含线程安全属性

## 明智审慎的使用延迟初始化

在大多数情况下，常规初始化优于延迟初始化

## 优先选择 Java 序列化的替代方案

## 非常谨慎地实现 Serializable

- 实现 Serializable 接口的一个主要代价是，一旦类的实现被发布，它就会降低更改该类实现的灵活性
- 实现 Serializable 接口的第二个代价是，增加了出现 bug 和安全漏洞的可能性(第85项)。
- 实现 Serializable 接口的第三个代价是，它增加了与发布类的新版本相关的测试负担
- 实现 Serializable 接口并不是一个轻松的决定
- 为继承而设计的类（详见第 19 条）很少情况适合实现 Serializable 接口，接口也很少情况适合扩展它。
- 内部类（详见第 24 条）不应该实现 Serializable

## 考虑使用自定义的序列化形式

- 在没有考虑默认序列化形式是否合适之前，不要接受它
- 如果对象的物理表示与其逻辑内容相同，则默认的序列化形式可能是合适的。
- 即使你认为默认的序列化形式是合适的，你通常也必须提供 readObject 方法来确保不变性和安全性

使用默认的序列化形式有四个缺点：

- 它将导出的 API 永久地绑定到当前的内部实现。
- 它会占用过多的空间
- 它会消耗过多的时间
- 它可能导致堆栈溢出

## 考虑用序列化代理代替序列化实例
