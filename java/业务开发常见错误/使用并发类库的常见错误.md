**开发人员使用并发工具来解决线程安全问题时容易犯的四类错**

1. 只知道使用并发工具，但并不清楚当前线程的来龙去脉，解决多线程问题却不了解线程。
2. 误以为使用了并发工具就可以解决一切线程安全问题，期望通过把线程不安全的类替换为线程安全的类来一键解决问题。
3. 没有充分了解并发工具的特性，还是按照老方式使用新工具导致无法发挥其性能
4. 没有了解清楚工具的适用场景，在不合适的场景下使用了错误的工具导致性能更差

## 使用了线程安全的并发工具，并不代表解决了所有线程安全问题

ConcurrentHashMap 只能保证提供的原子性读写操作是线程安全的。

ConcurrentHashMap 这个篮子本身，可以确保多个工人在装东西进去时，不会相互影响干扰，但无法确保工人 A 看到还需要装 100 个桔子但是还未装的时候，工人 B 就看不到篮子中的桔子数量。更值得注意的是，你往这个篮子装 100 个桔子的操作不是原子性的，在别人看来可能会有一个瞬间篮子里有 964 个桔子，还需要补 36 个桔子。

ConcurrentHashMap 对外提供的方法或能力的限制：

- 使用了 ConcurrentHashMap，不代表对它的多个操作之间的状态是一致的，是没有其他线程在操作它的，如果需要确保需要手动加锁。
- 诸如 size、isEmpty 和 containsValue 等聚合方法，在并发情况下可能会反映 ConcurrentHashMap 的中间状态。因此在并发情况下，这些方法的返回值只能用作参考，而不能用于流程控制。显然，利用 size 方法计算差异值，是一个流程控制。
- 诸如 putAll 这样的聚合方法也不能确保原子性，在 putAll 的过程中去获取数据可能会获取到部分数据。

## 按照老方式使用新工具导致无法发挥其性能

**粗暴的解决方法：对使用 concurrentHashMap 的代码逻辑加锁。性能很差。**

优雅方式：使用 ConcurrentHashMap 的原子性方法 `computeIfAbsent` 来做复合逻辑操作，高性能。

computeIfAbsent 为什么如此高效呢？答案就在源码最核心的部分，也就是 Java 自带的 Unsafe 实现的 CAS。它在虚拟机层面确保了写入数据的原子性，比加锁的效率高得多。

## 没有认清并发工具的使用场景，因而导致性能问题

CopyOnWrite 是一个时髦的技术，不管是 Linux 还是 Redis 都会用到。在 Java 中，CopyOnWriteArrayList 虽然是一个线程安全的 ArrayList，但因为其实现方式是，每次修改数据时都会复制一份数据出来，所以有明显的适用场景，即读多写少或者说希望无锁读的场景。如果使用了 CopyOnWriteArrayList 来缓存大量的数据，而数据变化又比较频繁，则会消耗大量的性能。

